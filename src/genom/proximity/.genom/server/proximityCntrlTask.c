
/* --- FILE GENERATED BY GENOM, DO NOT EDIT BY HAND ------------------- */

/* 
 *      Autonomous Systems Lab, Swiss Federal Institute of Technology.
 * Copyright (c) 1993-2005 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution and use  in source  and binary  forms,  with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice,  this list of  conditions and the following disclaimer in
 *      the  documentation  and/or  other   materials provided  with  the
 *      distribution.
 *
 * THIS  SOFTWARE IS PROVIDED BY  THE  COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND  ANY  EXPRESS OR IMPLIED  WARRANTIES,  INCLUDING,  BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR  PURPOSE ARE DISCLAIMED. IN  NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR      CONTRIBUTORS  BE LIABLE FOR   ANY    DIRECT, INDIRECT,
 * INCIDENTAL,  SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE   OF THIS SOFTWARE, EVEN   IF ADVISED OF   THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/*
 * Control task body
 */

#if defined(__RTAI__) && defined(__KERNEL__)
# define exit(x)	taskDelete(0)
#else
# include <stdlib.h>
# include <unistd.h>
# include <signal.h>
#endif

#include <portLib.h>

#include "proximityHeader.h"

#include <taskLib.h> 
#include <errnoLib.h>
#include <commonStructLib.h>
#include <h2evnLib.h>
#include <h2timerLib.h>

#include "proximityMsgLib.h"
#include "genom/genom.h"
#include "genom/moduleEvents.h"

/* Print debugging information */
#define GENOM_DEBUG_CNTRLTASK

#ifdef GENOM_DEBUG_CNTRLTASK
# define LOGDBG(x)	logMsg x
#else
# define LOGDBG(x)
#endif

/*-------------------- VARIABLES IMPORTEES ---------------------------------*/

/* Semaphores d'initialisation et de debug */
extern SEM_ID semproximityCntrlTaskInit;   

extern char pidFilePath[];

/*-------------------- VARIABLES GLOBALES ---------------------------------*/

/* Nombre d'activites ZOMBIE */
/*XXXXX Voila une variable qu'il serait judicieux de mettre de la SDI de controle a l'occasion XXXXX*/
static int proximityNbZombie=0;
static POSTER_ID proximityCntrlPosterId;            /* Poster de controle */
static int proximityLastActivityNum=-1;
static int proximityLastAbsolutActivityNum=-1;

static char *proximityExecTaskNameTab[] = {
"proximityTask"
};
static BOOL proximitySignalAbort;

#define TIMEOUT_CNTRL_TASK 2000 /* 10 sec (pas encore utilise) */

static MODULE_EVENT_STR moduleEventCntrl;

/*---------------- PROTOTYPES DES FONCTIONS LOCALES ------------------------*/

static void   proximityCntrlIntEvnExec   (SERV_ID ServId);
static void   proximityCntrlExtEvnExec   (SERV_ID ServId);
static void   proximitySpawnActivities   (SERV_ID servId);
static void   proximityCntrlPosterWrite  (void);
static BOOL   proximityAbortActivity     (SERV_ID servId, int activity);
static STATUS proximityCntrlInitTask     (SERV_ID *ServId);
static int    allocActivity             (int rqstId, 
					 int requestNum, 
					 int execTaskNum, 
					 int reentrantFlag,
					 SERV_ID servId);
static void   freeActivity              (int activity);
static BOOL   controlExecTaskStatus(SERV_ID servId, int rqstId);
static BOOL   controlExecTaskStatusAndInitRqst(SERV_ID servId, int rqstId);
static void   proximitySendFinalReply    (SERV_ID servId, int activity);
static void   proximityRqstAbortActivity (SERV_ID ServId, int rqstId);
static void   proximityCntrlTaskSuspend  (BOOL giveFlag);
static void   proximityReplyAndSuspend   (SERV_ID servId, int rqstId, 
					 BOOL giveFlag);      
static void   proximitySignalHandler(int);
static void   proximitySignalEnd(void);

/*---------------------- FONCTION EXPORTEE ---------------------------------*/

/*****************************************************************************
 *
 *   proximityCntrlTask - Tache de controle du module PROXIMITY
 *
 *   Description:
 *   Cette tache attend suspendue l'arrivee de messages dans sa boite de
 *   reception ou d'evenements internes. A la reception d'une lettre,
 *   la requete correspondante est traitee. Les changement d'etat internes 
 *   sont pris en compte et les repliques finales sont emises au client.
 *   Cette tache boucle a jamais.
 */

void *
proximityCntrlTask(void *arg)
{
  static SERV_ID proximityServId;              /* Id du serveur */

  /* Routine d'initialisation */
  CNTRL_TASK_STATUS = proximityCntrlInitTask (&proximityServId);
  if (CNTRL_TASK_STATUS == ERROR)
     CNTRL_TASK_BILAN = errnoGet();
  else
     CNTRL_TASK_BILAN = OK;
  
  /* Donner le sem de fin d'initialisation */
  semGive (semproximityCntrlTaskInit) ;

  /* Se suspendre en cas de probleme */
  if (CNTRL_TASK_STATUS == ERROR) {
     proximityCntrlTaskSuspend(FALSE);
  }

  moduleEventCntrl.moduleNum = 2005;

  /* Record a signal handler */
  proximitySignalAbort = FALSE;
  signal(SIGTERM, proximitySignalHandler);
  /* Boucler indefiniment */
  FOREVER
    {
      /* Bloquer dans l'attente d'evenements internes et externes */
      if (h2evnSusp (0) != TRUE)
	 proximityCntrlTaskSuspend (FALSE);

      /* Prendre l'acces aux SDI */
      commonStructTake ((void *) proximityCntrlStrId);
      commonStructTake ((void *) proximityDataStrId);
 
      if (proximitySignalAbort) {
	      proximitySignalEnd();
      }
      /* Traiter les evenements internes */
      proximityCntrlIntEvnExec (proximityServId);

      /* Traiter les evenements externes */
      proximityCntrlExtEvnExec (proximityServId);

      /* Lancer les activites en attentes */
      proximitySpawnActivities(proximityServId);

      /* Mettre a jour le poster de controle */
      proximityCntrlPosterWrite();

      CNTRL_TASK_BILAN = errnoGet();

     /* Liberer l'acces aux SDI */
      commonStructGive ((void *) proximityDataStrId);
      commonStructGive ((void *) proximityCntrlStrId);

    }
  return NULL;
}



/*-------------------- ROUTINES LOCALES ------------------------------------*/


 
/*****************************************************************************
 *
 *  proximityCntrlIntEvnExec  -  Traiter les evenements internes produits
 *                              par les taches d'execution
 */

static void proximityCntrlIntEvnExec(SERV_ID servId)
{
  int activity;

  /* Activites terminees ou activite a reveiller */
  for (activity = 0;  activity < MAX_ACTIVITIES; activity++) {

    /* Activite terminee */
    if (ACTIVITY_EVN(activity) == ETHER) {
      
      /* Est-ce l'activité d'init ? */
      if (INIT_RQST != -1)
	if (ACTIVITY_RQST_TYPE(activity) == INIT_RQST)
	  if (ACTIVITY_BILAN(activity) == OK)
	    INIT_RQST = -1;

      /* On envoie la replique finale */
      proximitySendFinalReply (servId, activity);
      
      /* On libere l'activite */
      freeActivity (activity);
    }
    
    /* Activite suspendue */
    else if (ACTIVITY_EVN(activity) == ZOMBIE) {
      
      /* On envoie la replique finale */
      proximitySendFinalReply (servId, activity);

      /* On bloque l'activite */
      proximityNbZombie++;
      ACTIVITY_STATUS(activity) = ZOMBIE;
      ACTIVITY_EVN(activity) = NO_EVENT;
    }

    /* Activite en attente */
    else if (ACTIVITY_EVN(activity) == SLEEP) {
      ACTIVITY_STATUS(activity) = SLEEP;
      ACTIVITY_EVN(activity) = NO_EVENT;
    }

    /* XXX Eveil systematique - le traitement des requetes est fait apres -> si l'une d'elle met le flag EXEC_TASK_WAKE_UP_FLAG on ne le voie pas ici */
/*    else if (ACTIVITY_STATUS(activity) == SLEEP) {*/
/*      && EXEC_TASK_WAKE_UP_FLAG(ACTIVITY_TASK_NUM(activity))) {*/
/*      ACTIVITY_EVN(activity) = EXEC;
      h2evnSignal(EXEC_TASK_ID(ACTIVITY_TASK_NUM(activity)));
    }*/

  } /* for */

  /* Reset demande d'eveil (pas utilise actuelement) */
/*  for (i=0; i<PROXIMITY_NB_EXEC_TASK; i++)
    EXEC_TASK_WAKE_UP_FLAG(i) = FALSE;*/
}


/*****************************************************************************
 *
 *  proximityCntrlExtEvnExec  -  Traiter les evenements externes: arrivee
 *                              de requetes
 */

static void proximityCntrlExtEvnExec (SERV_ID proximityServId)
     
{
  int mboxStatus;                    /* Etat de la boite aux lettres */
  int status;
  int i;
  BOOL wakeUp=FALSE;
  
  /* Obtenir l'etat de la boite aux lettres de reception de requetes */
  status = (mboxStatus = csMboxStatus (RCV_MBOX));
 
  /* Execution de la requete */
  if (mboxStatus & RCV_MBOX)  {
    status = csServRqstExec (proximityServId);
    wakeUp = TRUE;
  }

  /* Suspendre la tache, en cas d'erreur */
  if (status == ERROR)
    proximityCntrlTaskSuspend (TRUE);

  /* On eveil toutes les taches d'exec (non periodique) un petit coup */
  if (wakeUp)
    for (i=0; i<PROXIMITY_NB_EXEC_TASK; i++)
      if (!EXEC_TASK_PERIOD(i)) h2evnSignal(EXEC_TASK_ID(i));
}

/*****************************************************************************
 *
 *  proximitySpawnActivities  -  Lancer les activitees pretes
 *
 *  Description:  Pour chaque activite en attente, regarde si les activites
 *                incompatibles ont ete arretees. En ce cas lance l'activite.
 */

static void proximitySpawnActivities (SERV_ID servId)
     
{
  int activity;
  int i, j;
  int nbIncomp;

  /* Pour chaque activite */
  for (activity = 0; activity < MAX_ACTIVITIES; activity++) 

    /* Activite en attente */
    if (ACTIVITY_STATUS(activity) == INIT 
	&& ACTIVITY_EVN(activity) == NO_EVENT) {
      
      /* Activite incompatibles */
      nbIncomp = ACTIVITY_NB_INCOMP(activity);
      
      /* Liste des activites encore incompatibles */
      for (i=0, j=0; i<nbIncomp; i++)
	if (ACTIVITY_STATUS(ACTIVITY_TAB_INCOMP(activity)[i]) == ETHER
	    || ACTIVITY_STATUS(ACTIVITY_TAB_INCOMP(activity)[i]) == ZOMBIE)
	  ACTIVITY_NB_INCOMP(activity)--;
	else
	  ACTIVITY_TAB_INCOMP(activity)[j++]
	    = ACTIVITY_TAB_INCOMP(activity)[i]; 
      
      /* Il n'y a plus d'activite incompatible */
      if (ACTIVITY_NB_INCOMP(activity) == 0) {
    
	/* Declencher l'execution */
	ACTIVITY_EVN(activity) = START;
	h2evnSignal(EXEC_TASK_ID(ACTIVITY_TASK_NUM(activity)));
	
	/* Envoyer la replique intermediaire */
	if (csServReplySend (servId, ACTIVITY_RQST_ID(activity), INTERMED_REPLY, 
			     OK, (void *) &ACTIVITY_ID(activity), sizeof(int), 
			     (FUNCPTR) NULL) != OK)
	  proximityCntrlTaskSuspend (TRUE);
      }      /* Activite a lancer */
    }        /* Activite en attente */
}


/*****************************************************************************
 *
 *  proximityCntrlPosterWrite  - Met a jour le poster de controle
 *
 *  Description: Se suspend en cas d'erreur
 */

static void proximityCntrlPosterWrite ()
{
  if (posterWrite (proximityCntrlPosterId, 0, (void *) proximityCntrlStrId,
		   sizeof (PROXIMITY_CNTRL_STR))
      != sizeof (PROXIMITY_CNTRL_STR)) {
    h2perror("proximityCntrlPosterWrite");
    proximityCntrlTaskSuspend (TRUE);
  }
}

/*-------------------- FONCTIONS AUXILIAIRES -------------------------------*/

static void proximityCntrlcheckLeftSensors(SERV_ID servId, int rqstId);
static void proximityCntrlcheckRightSensors(SERV_ID servId, int rqstId);
static void proximityCntrlcheckTopSensors(SERV_ID servId, int rqstId);
static void proximityCntrlcheckBackSensors(SERV_ID servId, int rqstId);

static void (*proximityTabRequestFunc[])() = {
proximityCntrlcheckLeftSensors,
proximityCntrlcheckRightSensors,
proximityCntrlcheckTopSensors,
proximityCntrlcheckBackSensors
};
static int proximityTabRequestNum[] = {
0, 1, 2, 3};



/*****************************************************************************
 *
 *  proximityCntrlInitTask - Routine d'initialisation de la tache de controle
 */


static STATUS
proximityCntrlInitTask(SERV_ID *proximityServId)
{
  int i;

  CNTRL_SDI_F = SDI_F;

  /* Creation de la boite aux lettres de reception des requetes */
  if (csMboxInit (PROXIMITY_MBOX_NAME, 
		  PROXIMITY_MBOX_RQST_SIZE, 0)
      != OK) {
    logMsg("proximityCntrlTask: csMboxInit: ");
    h2printErrno(errnoGet());
    return (ERROR);
  }
  LOGDBG(("proximityCntrlInitTask: created mailbox\n"));
  
  /* S'initialiser comme serveur */
  if (csServInitN (PROXIMITY_MAX_RQST_SIZE, 
		  PROXIMITY_MAX_REPLY_SIZE >= PROXIMITY_MAX_INTERMED_REPLY_SIZE ?
		  PROXIMITY_MAX_REPLY_SIZE : PROXIMITY_MAX_INTERMED_REPLY_SIZE, 
		  NB_RQST_TYPE,
		  proximityServId) 
      != OK) { 
    logMsg("proximityCntrlTask: csServInit: ");
    h2printErrno(errnoGet());
    return (ERROR);
  }
  LOGDBG(("proximityCntrlInitTask: initialized mailbox as a server\n"));
  
  /* Installer les routines de traitement des requetes */
  for (i=0; i<NB_RQST_TYPE-1; i++) {
    if (csServFuncInstall (*proximityServId, proximityTabRequestNum[i], 
			   (FUNCPTR) proximityTabRequestFunc[i]) != OK) {
      logMsg("proximityCntrlTask: csServFuncInstall: ");
      h2printErrno(errnoGet());
      return (ERROR);
    }
  }
  LOGDBG(("proximityCntrlInitTask: installed requests\n"));

  /* Installer la requete abort
     (c'est le parser qui attribue le premier numero libre de requete ) */
  if (csServFuncInstall (*proximityServId, 4, 
			 (FUNCPTR) proximityRqstAbortActivity) != OK) {
    logMsg("proximityCntrlTask: csServFuncInstall: ");
    h2printErrno(errnoGet());
    return (ERROR);
  }
  LOGDBG(("proximityCntrlInitTask: installed abort request\n"));
  
  /* Initialiser la structure de controle */
  STOP_MODULE_FLAG = FALSE;
  for (i=0; i<MAX_ACTIVITIES; i++) {
    ACTIVITY_STATUS(i) = ETHER;
    ACTIVITY_EVN(i) = NO_EVENT;
    ACTIVITY_TASK_NUM(i) = -1;
  }
  for (i=0; i<PROXIMITY_NB_EXEC_TASK; i++)
    EXEC_TASK_NB_ACTI(i) = 0;

  CNTRL_NB_EXEC_TASKS = PROXIMITY_NB_EXEC_TASK;

  /* La requete d'init */
  INIT_RQST = -1;

  /* Creer le poster de controle */
  if (posterCreate (PROXIMITY_CNTRL_POSTER_NAME, sizeof (PROXIMITY_CNTRL_STR), 
                    &proximityCntrlPosterId) != OK) {
    logMsg("proximityCntrlTask: posterCreate: ");
    h2printErrno(errnoGet());
    return (ERROR);
  }
  LOGDBG(("proximityCntrlInitTask: created control poster\n"));
 
  /* Obtenir son propre identificateur de tache */
  CNTRL_TASK_ID = taskIdSelf ();
  NB_ACTIVITIES = 0;

  /* Record errors */
  proximityRecordH2errMsgs();

  /* C'est OK */
  return (OK);
}

/*****************************************************************************
 *
 *  proximityAbortActivity -  Arrete une activite
 *
 *  Description : Demande l'arret de l'activite si celle ci n'est pas
 *                deja arretee. Si elle est deja arretee, libere l'activite.
 *
 *  Retourne : TRUE si activite terminee, FALSE sinon
 */
 
static BOOL proximityAbortActivity (SERV_ID servId, int activity)
{
  
  switch (ACTIVITY_STATUS(activity)) {
    
    /* Activite inexistante */
  case ETHER:
    return(TRUE);

    /* Activite plantee */
  case ZOMBIE:
    freeActivity(activity);
    return(TRUE);
    
    /* Activite pas encore demarree */
  case INIT:
    proximitySendFinalReply(servId, activity);
    freeActivity (activity);
    return(TRUE);

    /* L'acitivite roupille */
  case SLEEP:
    ACTIVITY_EVN(activity) = INTER;
    h2evnSignal(EXEC_TASK_ID(ACTIVITY_TASK_NUM(activity)));
    return(FALSE);
    
    /* Activite en cours d'exec: START, EXEC, END, FAIL, INTER , SLEEP */
  default:
    switch (ACTIVITY_EVN(activity)) {
      
      /* Activite terminee */
    case ETHER:
      proximitySendFinalReply(servId, activity);
      freeActivity (activity);
      return(TRUE);
      
      /* Activite va se planter */
    case FAIL:
      return(FALSE);

      /* Interruption deja demandee */
    case INTER:
      return FALSE;

      /* Demande d'interruption END, START, EXEC, SLEEP? */
    default:
      ACTIVITY_EVN(activity) = INTER;
      h2evnSignal(EXEC_TASK_ID(ACTIVITY_TASK_NUM(activity)));
      return(FALSE);
    }
  }
}

/****************************************************************************
 *
 *  allocActivity  -  Allocation/Initialisation d'une activite
 *
 *  Retourne : Numero de l'activite ou -1
 */

static int allocActivity (int rqstId,     /* Id de la requete */
			  int requestNum, /* Type d'activite */
			  int execTaskNum,
			  int reentrantFlag,
			  SERV_ID servId)
{
  int activity, i;
  
  /* Il y a une activite ZOMBIE */
  if (proximityNbZombie != 0) {
    if (csServReplySend (servId, rqstId, FINAL_REPLY, 
			 S_proximity_stdGenoM_WAIT_ABORT_ZOMBIE_ACTIVITY, 
			 (void *) NULL, 0, (FUNCPTR) NULL) != OK)
      proximityCntrlTaskSuspend (TRUE);
    return -1;
  }

  /* Recherche d'une activite libre */
  /*  activity = 0;
  while(ACTIVITY_STATUS(activity) != ETHER && activity < MAX_ACTIVITIES) 
    activity++;*/

  
  for(i=0; i<MAX_ACTIVITIES; i++) {
    activity = (proximityLastActivityNum+1+i)%MAX_ACTIVITIES;
    if (ACTIVITY_STATUS(activity) == ETHER)
      break;
  }

  /* Pas d'activite libre */
  if (/*activity*/ i == MAX_ACTIVITIES) {
    if (csServReplySend (servId, rqstId, FINAL_REPLY, 
			 S_proximity_stdGenoM_TOO_MANY_ACTIVITIES, 
			 (void *) NULL, 0, (FUNCPTR) NULL) != OK)
      proximityCntrlTaskSuspend (TRUE);
    return -1;
  }

  proximityLastActivityNum = activity;
  proximityLastAbsolutActivityNum++;

  /* Cree l'activite */
  ACTIVITY_STATUS(activity) = INIT;
  ACTIVITY_EVN(activity) = NO_EVENT;
  ACTIVITY_RQST_TYPE(activity) = requestNum;
  ACTIVITY_RQST_ID(activity) = rqstId;
  ACTIVITY_ID(activity) = proximityLastAbsolutActivityNum;
  ACTIVITY_BILAN(activity) = OK;
  ACTIVITY_NB_INCOMP(activity) = 0;
  ACTIVITY_TASK_NUM(activity) = execTaskNum;
  ACTIVITY_REENTRANCE(activity) = reentrantFlag;

  /* Initialise les parametres */
  ACTIVITY_INPUT_ID(activity) = NULL;
  ACTIVITY_INPUT_SIZE(activity) = 0;
  ACTIVITY_OUTPUT_ID(activity) = NULL;
  ACTIVITY_OUTPUT_SIZE(activity) = 0;

  /* Une activite de plus */
  EXEC_TASK_NB_ACTI(execTaskNum)++;
  NB_ACTIVITIES++;

  return(activity);
}

/****************************************************************************
 *
 *  controlExecTaskStatus  -  Controle l'état des tâches d'exec
 *
 */
static BOOL controlExecTaskStatus(SERV_ID servId, int rqstId)
{
  int i;

  /* Exec tasks status */
  for (i=0; i<PROXIMITY_NB_EXEC_TASK; i++)
    if (EXEC_TASK_STATUS(i) == ERROR) {
      /* XXXXX Il faudrait definir un bilan spécifique:
	 S_proximity_stdGenoM_EXEC_TASK_SUSPENDED */
      csServReplySend (servId, rqstId, FINAL_REPLY, 
		       S_proximity_stdGenoM_SYSTEM_ERROR,
		       (void *) NULL, 0, (FUNCPTR) NULL);
      return FALSE;
    }

  return TRUE;
}

/****************************************************************************
 *
 *  controlExecTaskStatusAndInitRqst  -  Controle l'état des tâches d'exec
 *					 et la requete d'init
 *
 */
static BOOL controlExecTaskStatusAndInitRqst(SERV_ID servId, int rqstId)
{
  int i;

  /* Exec tasks status */
  for (i=0; i<PROXIMITY_NB_EXEC_TASK; i++)
    if (EXEC_TASK_STATUS(i) == ERROR) {
      /* XXXXX Il faudrait definir un bilan spécifique:
	 S_proximity_stdGenoM_EXEC_TASK_SUSPENDED */
      csServReplySend (servId, rqstId, FINAL_REPLY, 
		       S_proximity_stdGenoM_SYSTEM_ERROR,
		       (void *) NULL, 0, (FUNCPTR) NULL);
      return FALSE;
    }

  /* Init request */
  if (INIT_RQST != -1) {
    csServReplySend (servId, rqstId, FINAL_REPLY, 
		     S_proximity_stdGenoM_WAIT_INIT_RQST, 
		     (void *) NULL, 0, (FUNCPTR) NULL);
    return FALSE;
  }    

  return TRUE;
}

/****************************************************************************
 *
 *  freeActivity  -  Retire l'activite du tableau d'activite
 */

static void freeActivity (int activity)
{
  int execTaskNum;
  
  /* C'etait une activite ZOMBIE */
  if (ACTIVITY_STATUS(activity) == ZOMBIE) proximityNbZombie--;

  /* Petit netoyage */
  execTaskNum = ACTIVITY_TASK_NUM(activity);
  ACTIVITY_STATUS(activity) = ETHER;
  ACTIVITY_EVN(activity) = NO_EVENT;
  ACTIVITY_TASK_NUM(activity) = -1;
  EXEC_TASK_NB_ACTI(execTaskNum)--;
  NB_ACTIVITIES --;
}


/****************************************************************************
 *
 *  proximitySendFinalReply  -  Envoie la replique finale
 *
 *  Description : Envoie la replique finale avec le bilan d'execution si 
 *                tout c'est bien termine' (dernier etat END), ou avec un 
 *                message d'interruption (dernier etat INTER ou INIT)
 *                ou d'echec (dernier etat FAIL).
 */

static void proximitySendFinalReply (SERV_ID servId,
				    int activity)

{
  int bilan;

  /* 
   * Select bilan according to the last event 
   */
  switch(ACTIVITY_EVN(activity)) {

    /* Normal end or "clean" interruption */
  case ETHER:
    /* Clean interruption or not yet started  */
    if (ACTIVITY_STATUS(activity) == INIT ||
	ACTIVITY_STATUS(activity) == INTER) {
      bilan = S_proximity_stdGenoM_ACTIVITY_INTERRUPTED;
      ACTIVITY_BILAN(activity) = bilan;
    }
    
    /* Normal end */
    else {
      bilan = ACTIVITY_BILAN(activity);
      if (bilan != OK && !H2_MODULE_ERR_FLAG(bilan)) {
	CNTRL_TASK_BILAN = bilan;
	bilan = S_proximity_stdGenoM_SYSTEM_ERROR;
      }
    }
    break;
    
    /* Activity not yet started */
  case START:
    if (ACTIVITY_STATUS(activity) == INIT) {
      bilan = S_proximity_stdGenoM_ACTIVITY_INTERRUPTED;
      ACTIVITY_BILAN(activity) = bilan;      
    }
    break;

    /* Echec */
  case ZOMBIE:
    bilan = S_proximity_stdGenoM_ACTIVITY_FAILED;
    break;

    /* Interruption before starting (state == INIT) */
  case NO_EVENT:
    bilan = S_proximity_stdGenoM_ACTIVITY_INTERRUPTED;
    ACTIVITY_BILAN(activity) = bilan;
    break;

    /* Impossible termination event */
  default:
    logMsg("proximityCntrlTask: activity %d state %d event %d !?! \n", 
	   activity, ACTIVITY_STATUS(activity), ACTIVITY_EVN(activity));
    errnoSet(S_proximity_stdGenoM_FORBIDDEN_ACTIVITY_TRANSITION);
    bilan = S_proximity_stdGenoM_FORBIDDEN_ACTIVITY_TRANSITION;
    ACTIVITY_BILAN(activity) = bilan;
  }
  
  /* 
   * Send the final reply 
   */
  if (csServReplySend (servId, ACTIVITY_RQST_ID(activity), FINAL_REPLY, 
		       bilan, (void *) ACTIVITY_OUTPUT_ID(activity),
		       ACTIVITY_OUTPUT_SIZE(activity), (FUNCPTR) NULL) != OK)
    proximityCntrlTaskSuspend (TRUE);

  moduleEventCntrl.eventType = STATE_END_EVENT;
  moduleEventCntrl.activityNum = activity;
  moduleEventCntrl.activityState = ACTIVITY_EVN(activity);
  moduleEventCntrl.rqstType = ACTIVITY_RQST_TYPE(activity);
  moduleEventCntrl.taskNum = ACTIVITY_TASK_NUM(activity);
  sendModuleEvent(&moduleEventCntrl);
}


/****************************************************************************
 *
 *  proximityCntrlTaskSuspend  -  Suspension de la tache de controle
 *
 *  Description : recupere le bilan, puis suspend la tache de controle
 *
 */

static void proximityCntrlTaskSuspend (BOOL giveFlag)

{
  char strerr[64];

  /* Indiquer qu'une erreur a ete detectee */
  CNTRL_TASK_STATUS = ERROR;
  CNTRL_TASK_BILAN = errnoGet();

  logMsg("proximityCntrlTaskSuspend: %s\n", h2getErrMsg(CNTRL_TASK_BILAN, strerr, 64));

  /* Mettre a jour le poster de controle */
  if (posterWrite (proximityCntrlPosterId, 0, (void *) proximityCntrlStrId,
		   sizeof (PROXIMITY_CNTRL_STR)) != sizeof (PROXIMITY_CNTRL_STR)) {
    h2perror("proximityCntrlTaskSuspend: posterWrite");
  }

   /* Liberer les SDIs */
  if (giveFlag) {
    commonStructGive ((void *) proximityDataStrId);
    commonStructGive ((void *) proximityCntrlStrId);    
  }

  /* Suspendre la tache */
  taskSuspend (0);
}



/****************************************************************************
 *
 *  proximityReplyAndSuspend  -  Repliquer et suspendre
 *
 *  Description : envoie la replique puis se suspend
 */

static void proximityReplyAndSuspend (SERV_ID servId,  
				     int rqstId,
				     BOOL giveFlag)
{
  char strerr[64];

  /* Indiquer qu'une erreur a ete detectee */
  CNTRL_TASK_STATUS = ERROR;
  CNTRL_TASK_BILAN = errnoGet();

  logMsg("proximityCntrlTaskReplyAndSuspend: %s\n", 
	 h2getErrMsg(CNTRL_TASK_BILAN, strerr, 64));

  /* Mettre a jour le poster de controle */
  if (posterWrite (proximityCntrlPosterId, 0, (void *) proximityCntrlStrId,
		   sizeof (PROXIMITY_CNTRL_STR)) != sizeof (PROXIMITY_CNTRL_STR)) {
    h2perror ("proximityReplyAndSuspend: posterWrite");
  }

/*XXX  proximityCntrlPosterShow();*/


  /* Liberer les SDIs */
  if (giveFlag) {
    commonStructGive ((void *) proximityDataStrId);
    commonStructGive ((void *) proximityCntrlStrId);    
  }

  /* Envoyer le code d'erreur vers le client */
  (void) csServReplySend (servId, rqstId, FINAL_REPLY, CNTRL_TASK_BILAN, 
			  (void *) NULL, 0, (FUNCPTR) NULL);

  /* Suspendre la tache */
  taskSuspend (0);

}

/*------------------- TRAITEMENT DES REQUETES  -----------------------------*/


/****************************************************************************
 *
 *  proximityRqstAbortActivity  -  Traitement de la requete Abort
 */

static void proximityRqstAbortActivity (SERV_ID servId, int rqstId)

{
  int activityId; /* Absolut activity id */
  int activity; /* Local activity Id */
  int bilan = OK;
  int i;

  /* Get activity to abort */
  if (csServRqstParamsGet (servId, rqstId, (void *) &activityId, 
			   sizeof(int), (FUNCPTR) NULL) != OK)
    proximityReplyAndSuspend (servId, rqstId, TRUE);

  /* Activity identification */
  if (activityId < 0) {

    switch (activityId) 
      {
	/* Activity -88: restart suspended exec tasks */
      case GENOM_RESUME_EXEC_TASK:
	for (i=0; i<PROXIMITY_NB_EXEC_TASK; i++) {
	  taskResume(EXEC_TASK_ID(i));
	  EXEC_TASK_STATUS(i) = OK;
	}
	break;
    
      case GENOM_PRINT_TIME_RQST:
	if (GENOM_PRINT_TIME_FLAG) {
	  GENOM_PRINT_TIME_FLAG = 0;
	  /* reset time max for next display */
	  for (i=0; i<PROXIMITY_NB_EXEC_TASK; i++) {
	    EXEC_TASK_MAX_PERIOD(i) = 0;
	  }
	}
	else {
	  GENOM_PRINT_TIME_FLAG = 1;
	}
	break;

      case GENOM_VERBOSE_RQST:
	if (GENOM_VERBOSE_LEVEL)
	  GENOM_VERBOSE_LEVEL = 0;
	else
	  GENOM_VERBOSE_LEVEL = 1;
	break;

	/* Activity -99: stop the module */
      case GENOM_END_MODULE:

	/* Test if there is on going activities */
	if (NB_ACTIVITIES != 0) {
	  bilan = S_proximity_stdGenoM_WAIT_ABORT_ZOMBIE_ACTIVITY;
	  /* bilan = S_stdGenoM_ACTIVITIES_stdGenoM_REMAINED; */
	  break;
	}

	/* End the module */
	else {

	  STOP_MODULE_FLAG = TRUE;
	  for (i=PROXIMITY_NB_EXEC_TASK-1; i > -1; i--) 
	    EXEC_TASK_WAKE_UP_FLAG(i) = TRUE;

	  /* give back Internal Data Structures */
	  commonStructGive ((void *) proximityDataStrId);
	  commonStructGive ((void *) proximityCntrlStrId);

	  /* Interrupt exec task */
	  for (i=PROXIMITY_NB_EXEC_TASK-1; i > -1; i--) {
	    logMsg("Killing task %s ... \n", proximityExecTaskNameTab[i]);
	    taskResume(EXEC_TASK_ID(i));
	    h2evnSignal(EXEC_TASK_ID(i));
	  }

	  /* Wait end */
	  for (i=PROXIMITY_NB_EXEC_TASK-1; i > -1; i--) {
	    while (EXEC_TASK_WAKE_UP_FLAG(i))
	      h2evnSusp(0);
	    logMsg("    ... task %s killed\n", proximityExecTaskNameTab[i]);
	  }

	  /* send final reply */
	  csServReplySend (servId, rqstId, FINAL_REPLY, bilan, 
			   (void *) NULL, 0, (FUNCPTR) NULL);

	  
	  /* Destruction of mboxes, SDI and posters and BYE ! */
	  csMboxEnd();
	  commonStructDelete ((void *) proximityDataStrId);
	  commonStructDelete ((void *) proximityCntrlStrId);
	  posterDelete(proximityCntrlPosterId);
	  logMsg("proximityCntrlTask ended\n");
	  /* Remove PID file */
	  unlink(pidFilePath);
	  exit(0);
	}
	break;

      default:
	bilan = S_proximity_stdGenoM_UNKNOWN_ACTIVITY;
	break;
      } /* switch */
  }
  
  /* Numéro d'activité positive inconnu */
  else if(activityId > proximityLastAbsolutActivityNum) {
    bilan = S_proximity_stdGenoM_UNKNOWN_ACTIVITY;
  }
    
  /* Numéro valide */
  else {

    /* Recherche de l'activité */
    for (activity = 0; activity < MAX_ACTIVITIES; activity++)
      if (ACTIVITY_ID(activity) == activityId)
	break;

    /* Activité déjà terminée */
    if (activity == MAX_ACTIVITIES || ACTIVITY_STATUS(activity) == ETHER)
      bilan = S_proximity_stdGenoM_ACTIVITY_ALREADY_ENDED;

    /* Activité trouvée: interruption */
    else 
      proximityAbortActivity(servId, activity);
  }

  /* Send final reply */
  if (csServReplySend (servId, rqstId, FINAL_REPLY, bilan, 
		       (void *) NULL, 0, (FUNCPTR) NULL) != OK)
    proximityCntrlTaskSuspend (TRUE); 
}

/****************************************************************************
 * proximitySignalHandler - Handle signals in a module
 */
void
proximitySignalHandler(int sig)
{
	printf("Signal received %d\n", sig);
	proximitySignalAbort = TRUE;	/* indicate that we wanna end */
	h2evnSignal(CNTRL_TASK_ID);	/* wake up control task */
}

/****************************************************************************
 *
 * proximityEnd - terminate a module upon signal reception
 */
static void
proximitySignalEnd(void)
{
	int i;

	STOP_MODULE_FLAG = TRUE;
	for (i=PROXIMITY_NB_EXEC_TASK-1; i > -1; i--) 
		EXEC_TASK_WAKE_UP_FLAG(i) = TRUE;
	
	/* give back Internal Data Structures */
	commonStructGive ((void *) proximityDataStrId);
	commonStructGive ((void *) proximityCntrlStrId);
	
	/* Interrupt exec task */
	for (i=PROXIMITY_NB_EXEC_TASK-1; i > -1; i--) {
		logMsg("Killing task %s ... \n", proximityExecTaskNameTab[i]);
		taskResume(EXEC_TASK_ID(i));
		h2evnSignal(EXEC_TASK_ID(i));
	}
	
	/* Wait end */
	for (i=PROXIMITY_NB_EXEC_TASK-1; i > -1; i--) {
		while (EXEC_TASK_WAKE_UP_FLAG(i))
			h2evnSusp(0);
		logMsg("    ... task %s killed\n", proximityExecTaskNameTab[i]);
	}
	
	
	/* Destruction of mboxes, SDI and posters and BYE ! */
	csMboxEnd();
	commonStructDelete ((void *) proximityDataStrId);
	commonStructDelete ((void *) proximityCntrlStrId);
	posterDelete(proximityCntrlPosterId);
	logMsg("proximityCntrlTask ended\n");
	  /* Remove PID file */
	  unlink(pidFilePath);
	  exit(0);
}

/* Requetes de type controle */
/* Requetes de type execution */



/*****************************************************************************
 *
 *  proximityCntrlcheckLeftSensors - Execution request
 */

#if (0 /* control func */)
  extern int dummy ();
#endif 

static void proximityCntrlcheckLeftSensors (SERV_ID servId, int rqstId)

{
  static int proximitycheckLeftSensorsCompatibility[] = { 0, 0, 0, 0 };
  int activity;
  int i;
  int *compatibilityTab = proximitycheckLeftSensorsCompatibility;
#if ((0) && 0 /* Inputs + control func */)
  
#endif

  /*--------------------------------------------------------------
   * Control init done and exec tasks status 
   */
#if (1 /* not init rqst */)
  if (!controlExecTaskStatusAndInitRqst(servId, rqstId))
    return;  
#endif
 
  /*--------------------------------------------------------------
   * Activity allocation
   */
  activity = allocActivity(rqstId, 0, 0, 0, servId);
  if (activity == -1) return;

  /*--------------------------------------------------------------
   * Call control func
   */
#if (0 /* control func */)
  {
    STATUS status;
    int bilan;

#if ((0)  /* Input */)
    /* Get inputs */
    if (csServRqstParamsGet (servId, rqstId, (void *) NULL, 
			     0, (FUNCPTR) NULL) != OK)
      proximityReplyAndSuspend (servId, rqstId, TRUE);
    status = dummy (NULL, &bilan);
#else
    status = dummy (&bilan);
#endif

    /* Control not OK: stop there */
    if (status != OK) {
      freeActivity(activity);
      if (bilan == OK)
	bilan = S_proximity_stdGenoM_CONTROL_CODEL_ERROR;
      if (csServReplySend (servId, rqstId, FINAL_REPLY, bilan, 
			   (void *) NULL, 0, (FUNCPTR) NULL) != OK)
	proximityCntrlTaskSuspend (TRUE);
      return;
    }
  }
#endif

 /*-------------------------------------------------------------
  * Record inputs
  *       XXXXXXXX NON C'EST TROP TOT -> INTERROMPRE LES ACTIVITES AVANT !
  */
#if ((0) /* Input */)

  /* Get inputs address */
#if (0 /* multiple request  */)
  ACTIVITY_INPUT_ID(activity) = &(proximityDataStrId->checkLeftSensorsInput)[activity];
#else
  ACTIVITY_INPUT_ID(activity) = NULL;
#endif                
  ACTIVITY_INPUT_SIZE(activity) = 0;

  /* Record inputs */
#if (0 /* control func */)
  memcpy ((void *) ACTIVITY_INPUT_ID(activity), (void *) NULL, 
	  ACTIVITY_INPUT_SIZE(activity));
#else
  if (csServRqstParamsGet (servId, rqstId, ACTIVITY_INPUT_ID(activity), 
			   0, (FUNCPTR) NULL) != OK)
    proximityReplyAndSuspend (servId, rqstId, TRUE);
#endif
#endif          
  
 /*-------------------------------------------------------------
  * Get outputs address
  */
#if ((0) /* Output */)
#if (0 /* Multiple request */)
  ACTIVITY_OUTPUT_ID(activity) = 
    &(proximityDataStrId->checkLeftSensorsOutput)[activity];
#else
  ACTIVITY_OUTPUT_ID(activity) = NULL;
#endif            
  ACTIVITY_OUTPUT_SIZE(activity) = 0;
#endif          

  moduleEventCntrl.eventType = STATE_START_EVENT;
  moduleEventCntrl.activityNum = activity;
  moduleEventCntrl.activityState = INIT;
  moduleEventCntrl.rqstType = 0;
  moduleEventCntrl.taskNum = 0;
  sendModuleEvent(&moduleEventCntrl);

  /*-------------------------------------------------------------
   * Interruption of the incompatible activities
   */
  for (i = 0; i < MAX_ACTIVITIES; i++) 
    if (i != activity && ACTIVITY_STATUS(i) != ETHER 
	&& ! compatibilityTab[ACTIVITY_RQST_TYPE(i)]) 
      
      /* Record remaining incompatible activities */
      if (! proximityAbortActivity (servId, i)) {
	ACTIVITY_TAB_INCOMP(activity)[ACTIVITY_NB_INCOMP(activity)] = i;
	ACTIVITY_NB_INCOMP(activity)++;
      }  
}



/*****************************************************************************
 *
 *  proximityCntrlcheckRightSensors - Execution request
 */

#if (0 /* control func */)
  extern int dummy ();
#endif 

static void proximityCntrlcheckRightSensors (SERV_ID servId, int rqstId)

{
  static int proximitycheckRightSensorsCompatibility[] = { 0, 0, 0, 0 };
  int activity;
  int i;
  int *compatibilityTab = proximitycheckRightSensorsCompatibility;
#if ((0) && 0 /* Inputs + control func */)
  
#endif

  /*--------------------------------------------------------------
   * Control init done and exec tasks status 
   */
#if (1 /* not init rqst */)
  if (!controlExecTaskStatusAndInitRqst(servId, rqstId))
    return;  
#endif
 
  /*--------------------------------------------------------------
   * Activity allocation
   */
  activity = allocActivity(rqstId, 1, 0, 0, servId);
  if (activity == -1) return;

  /*--------------------------------------------------------------
   * Call control func
   */
#if (0 /* control func */)
  {
    STATUS status;
    int bilan;

#if ((0)  /* Input */)
    /* Get inputs */
    if (csServRqstParamsGet (servId, rqstId, (void *) NULL, 
			     0, (FUNCPTR) NULL) != OK)
      proximityReplyAndSuspend (servId, rqstId, TRUE);
    status = dummy (NULL, &bilan);
#else
    status = dummy (&bilan);
#endif

    /* Control not OK: stop there */
    if (status != OK) {
      freeActivity(activity);
      if (bilan == OK)
	bilan = S_proximity_stdGenoM_CONTROL_CODEL_ERROR;
      if (csServReplySend (servId, rqstId, FINAL_REPLY, bilan, 
			   (void *) NULL, 0, (FUNCPTR) NULL) != OK)
	proximityCntrlTaskSuspend (TRUE);
      return;
    }
  }
#endif

 /*-------------------------------------------------------------
  * Record inputs
  *       XXXXXXXX NON C'EST TROP TOT -> INTERROMPRE LES ACTIVITES AVANT !
  */
#if ((0) /* Input */)

  /* Get inputs address */
#if (0 /* multiple request  */)
  ACTIVITY_INPUT_ID(activity) = &(proximityDataStrId->checkRightSensorsInput)[activity];
#else
  ACTIVITY_INPUT_ID(activity) = NULL;
#endif                
  ACTIVITY_INPUT_SIZE(activity) = 0;

  /* Record inputs */
#if (0 /* control func */)
  memcpy ((void *) ACTIVITY_INPUT_ID(activity), (void *) NULL, 
	  ACTIVITY_INPUT_SIZE(activity));
#else
  if (csServRqstParamsGet (servId, rqstId, ACTIVITY_INPUT_ID(activity), 
			   0, (FUNCPTR) NULL) != OK)
    proximityReplyAndSuspend (servId, rqstId, TRUE);
#endif
#endif          
  
 /*-------------------------------------------------------------
  * Get outputs address
  */
#if ((0) /* Output */)
#if (0 /* Multiple request */)
  ACTIVITY_OUTPUT_ID(activity) = 
    &(proximityDataStrId->checkRightSensorsOutput)[activity];
#else
  ACTIVITY_OUTPUT_ID(activity) = NULL;
#endif            
  ACTIVITY_OUTPUT_SIZE(activity) = 0;
#endif          

  moduleEventCntrl.eventType = STATE_START_EVENT;
  moduleEventCntrl.activityNum = activity;
  moduleEventCntrl.activityState = INIT;
  moduleEventCntrl.rqstType = 1;
  moduleEventCntrl.taskNum = 0;
  sendModuleEvent(&moduleEventCntrl);

  /*-------------------------------------------------------------
   * Interruption of the incompatible activities
   */
  for (i = 0; i < MAX_ACTIVITIES; i++) 
    if (i != activity && ACTIVITY_STATUS(i) != ETHER 
	&& ! compatibilityTab[ACTIVITY_RQST_TYPE(i)]) 
      
      /* Record remaining incompatible activities */
      if (! proximityAbortActivity (servId, i)) {
	ACTIVITY_TAB_INCOMP(activity)[ACTIVITY_NB_INCOMP(activity)] = i;
	ACTIVITY_NB_INCOMP(activity)++;
      }  
}



/*****************************************************************************
 *
 *  proximityCntrlcheckTopSensors - Execution request
 */

#if (0 /* control func */)
  extern int dummy ();
#endif 

static void proximityCntrlcheckTopSensors (SERV_ID servId, int rqstId)

{
  static int proximitycheckTopSensorsCompatibility[] = { 0, 0, 0, 0 };
  int activity;
  int i;
  int *compatibilityTab = proximitycheckTopSensorsCompatibility;
#if ((0) && 0 /* Inputs + control func */)
  
#endif

  /*--------------------------------------------------------------
   * Control init done and exec tasks status 
   */
#if (1 /* not init rqst */)
  if (!controlExecTaskStatusAndInitRqst(servId, rqstId))
    return;  
#endif
 
  /*--------------------------------------------------------------
   * Activity allocation
   */
  activity = allocActivity(rqstId, 2, 0, 0, servId);
  if (activity == -1) return;

  /*--------------------------------------------------------------
   * Call control func
   */
#if (0 /* control func */)
  {
    STATUS status;
    int bilan;

#if ((0)  /* Input */)
    /* Get inputs */
    if (csServRqstParamsGet (servId, rqstId, (void *) NULL, 
			     0, (FUNCPTR) NULL) != OK)
      proximityReplyAndSuspend (servId, rqstId, TRUE);
    status = dummy (NULL, &bilan);
#else
    status = dummy (&bilan);
#endif

    /* Control not OK: stop there */
    if (status != OK) {
      freeActivity(activity);
      if (bilan == OK)
	bilan = S_proximity_stdGenoM_CONTROL_CODEL_ERROR;
      if (csServReplySend (servId, rqstId, FINAL_REPLY, bilan, 
			   (void *) NULL, 0, (FUNCPTR) NULL) != OK)
	proximityCntrlTaskSuspend (TRUE);
      return;
    }
  }
#endif

 /*-------------------------------------------------------------
  * Record inputs
  *       XXXXXXXX NON C'EST TROP TOT -> INTERROMPRE LES ACTIVITES AVANT !
  */
#if ((0) /* Input */)

  /* Get inputs address */
#if (0 /* multiple request  */)
  ACTIVITY_INPUT_ID(activity) = &(proximityDataStrId->checkTopSensorsInput)[activity];
#else
  ACTIVITY_INPUT_ID(activity) = NULL;
#endif                
  ACTIVITY_INPUT_SIZE(activity) = 0;

  /* Record inputs */
#if (0 /* control func */)
  memcpy ((void *) ACTIVITY_INPUT_ID(activity), (void *) NULL, 
	  ACTIVITY_INPUT_SIZE(activity));
#else
  if (csServRqstParamsGet (servId, rqstId, ACTIVITY_INPUT_ID(activity), 
			   0, (FUNCPTR) NULL) != OK)
    proximityReplyAndSuspend (servId, rqstId, TRUE);
#endif
#endif          
  
 /*-------------------------------------------------------------
  * Get outputs address
  */
#if ((0) /* Output */)
#if (0 /* Multiple request */)
  ACTIVITY_OUTPUT_ID(activity) = 
    &(proximityDataStrId->checkTopSensorsOutput)[activity];
#else
  ACTIVITY_OUTPUT_ID(activity) = NULL;
#endif            
  ACTIVITY_OUTPUT_SIZE(activity) = 0;
#endif          

  moduleEventCntrl.eventType = STATE_START_EVENT;
  moduleEventCntrl.activityNum = activity;
  moduleEventCntrl.activityState = INIT;
  moduleEventCntrl.rqstType = 2;
  moduleEventCntrl.taskNum = 0;
  sendModuleEvent(&moduleEventCntrl);

  /*-------------------------------------------------------------
   * Interruption of the incompatible activities
   */
  for (i = 0; i < MAX_ACTIVITIES; i++) 
    if (i != activity && ACTIVITY_STATUS(i) != ETHER 
	&& ! compatibilityTab[ACTIVITY_RQST_TYPE(i)]) 
      
      /* Record remaining incompatible activities */
      if (! proximityAbortActivity (servId, i)) {
	ACTIVITY_TAB_INCOMP(activity)[ACTIVITY_NB_INCOMP(activity)] = i;
	ACTIVITY_NB_INCOMP(activity)++;
      }  
}



/*****************************************************************************
 *
 *  proximityCntrlcheckBackSensors - Execution request
 */

#if (0 /* control func */)
  extern int dummy ();
#endif 

static void proximityCntrlcheckBackSensors (SERV_ID servId, int rqstId)

{
  static int proximitycheckBackSensorsCompatibility[] = { 0, 0, 0, 0 };
  int activity;
  int i;
  int *compatibilityTab = proximitycheckBackSensorsCompatibility;
#if ((0) && 0 /* Inputs + control func */)
  
#endif

  /*--------------------------------------------------------------
   * Control init done and exec tasks status 
   */
#if (1 /* not init rqst */)
  if (!controlExecTaskStatusAndInitRqst(servId, rqstId))
    return;  
#endif
 
  /*--------------------------------------------------------------
   * Activity allocation
   */
  activity = allocActivity(rqstId, 3, 0, 0, servId);
  if (activity == -1) return;

  /*--------------------------------------------------------------
   * Call control func
   */
#if (0 /* control func */)
  {
    STATUS status;
    int bilan;

#if ((0)  /* Input */)
    /* Get inputs */
    if (csServRqstParamsGet (servId, rqstId, (void *) NULL, 
			     0, (FUNCPTR) NULL) != OK)
      proximityReplyAndSuspend (servId, rqstId, TRUE);
    status = dummy (NULL, &bilan);
#else
    status = dummy (&bilan);
#endif

    /* Control not OK: stop there */
    if (status != OK) {
      freeActivity(activity);
      if (bilan == OK)
	bilan = S_proximity_stdGenoM_CONTROL_CODEL_ERROR;
      if (csServReplySend (servId, rqstId, FINAL_REPLY, bilan, 
			   (void *) NULL, 0, (FUNCPTR) NULL) != OK)
	proximityCntrlTaskSuspend (TRUE);
      return;
    }
  }
#endif

 /*-------------------------------------------------------------
  * Record inputs
  *       XXXXXXXX NON C'EST TROP TOT -> INTERROMPRE LES ACTIVITES AVANT !
  */
#if ((0) /* Input */)

  /* Get inputs address */
#if (0 /* multiple request  */)
  ACTIVITY_INPUT_ID(activity) = &(proximityDataStrId->checkBackSensorsInput)[activity];
#else
  ACTIVITY_INPUT_ID(activity) = NULL;
#endif                
  ACTIVITY_INPUT_SIZE(activity) = 0;

  /* Record inputs */
#if (0 /* control func */)
  memcpy ((void *) ACTIVITY_INPUT_ID(activity), (void *) NULL, 
	  ACTIVITY_INPUT_SIZE(activity));
#else
  if (csServRqstParamsGet (servId, rqstId, ACTIVITY_INPUT_ID(activity), 
			   0, (FUNCPTR) NULL) != OK)
    proximityReplyAndSuspend (servId, rqstId, TRUE);
#endif
#endif          
  
 /*-------------------------------------------------------------
  * Get outputs address
  */
#if ((0) /* Output */)
#if (0 /* Multiple request */)
  ACTIVITY_OUTPUT_ID(activity) = 
    &(proximityDataStrId->checkBackSensorsOutput)[activity];
#else
  ACTIVITY_OUTPUT_ID(activity) = NULL;
#endif            
  ACTIVITY_OUTPUT_SIZE(activity) = 0;
#endif          

  moduleEventCntrl.eventType = STATE_START_EVENT;
  moduleEventCntrl.activityNum = activity;
  moduleEventCntrl.activityState = INIT;
  moduleEventCntrl.rqstType = 3;
  moduleEventCntrl.taskNum = 0;
  sendModuleEvent(&moduleEventCntrl);

  /*-------------------------------------------------------------
   * Interruption of the incompatible activities
   */
  for (i = 0; i < MAX_ACTIVITIES; i++) 
    if (i != activity && ACTIVITY_STATUS(i) != ETHER 
	&& ! compatibilityTab[ACTIVITY_RQST_TYPE(i)]) 
      
      /* Record remaining incompatible activities */
      if (! proximityAbortActivity (servId, i)) {
	ACTIVITY_TAB_INCOMP(activity)[ACTIVITY_NB_INCOMP(activity)] = i;
	ACTIVITY_NB_INCOMP(activity)++;
      }  
}

